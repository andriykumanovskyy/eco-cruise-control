I have a long term goal to learn as much as I can out of this program so that I can apply it to implement an ECO cruise control algorithm for which I already did of a lot the real life testing and algorithm writing. One thing that would save me time (as well as empower other enthusiastic coders to pursue their ideas) would be to design a modified simulator from the Behavioral Cloning project but with no turns, just a straight line with hills. Additionally it would need the ability to change the mass of the car (varying the amount of passengers) and vary the rate of acceleration as time changes, or in my case, the position relative to what point the car is on a hill it encounters. This change in acceleration is much like real cars with real drivers have the option of varying the gas petal for variable amounts of acceleration (perhaps modifying the drive.py file should do the trick :)) This algorithm would essentially utilize a "look-ahead" feature (utilizing path planning which I have yet to learn) to look at the future peaks and troughs in the road's altitude (this is publicly available data via terrain maps) to then slightly gain speed as the car goes downhill, and slightly lose speed as the car goes uphill utilizing PID controllers, most likely with some damping (I have a lengthy mathematical proof I did to show this is the most energy efficient way of driving, so long as it doesn't go above 135 Km/h where drag losses overtake any transient energy efficiency gains in losing speed as one goes uphill). The limit variance would be very tight, and well within safe bounds (if speed limit is 100 Km/h for example, variance would be between 95 Km/h and 105 Km/h , or 100 Km/h and 110 Km/h ). This algorithm would always take safety first, and only trigger if neighboring cars are sufficiently far away. And finally, since the goal is to have a "one size" fit all if possible, a classifier algorithm will need to be implemented, probably after being fed into a deep/ reinforcement learning network with gradient, speed, distance, angle, ect as the feature set and acceleration amount on the petal as the label set. It will also need to be layered, perhaps binned for the potential of different weight the car may have demanding a different ideal acceleration amount even if the projected future gradients/angles/speed ect are the same. Another problem would be to teach the car to recognize the differences in weight, so a reinforcement learning approach might be warranted to help the car converge at the acceleration just right to bring it, for example, from the bottom of a trough going  110 Km/h an hour to the peak of the crest going 100 Km/h, expending less energy than it would usually need to go uphill.. and then gaining momentum while going downwards much easier for the next hill. This idea can be subdivided as many times as practical, since it might not be ideal to assume that each hill is roughly sinusoidal, however it is a very good starting assumption. To conclude, this idea is something that could definitely be streamlined if I do at least a small part of it with Udacity (as they have the source files for the simulator for example).
